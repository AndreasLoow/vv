let templates = Belt.Map.String.fromArray(
[("empty.sv","module empty;\n\n// Put Verilog code here!\n\n// See the modules in 00 (in the top-left menu) for some introductory notes!\n\nendmodule\n"),("nonblocking2.sv","module nonblocking2;\n\nlogic a;\n\n// a must be 0 at end of time slot\n\ninitial begin\n a <= 1'b0;\n a = 1'b1;\nend\n\nendmodule\n"),("always_comb2.sv","module always_comb2;\n\n// Examples from the standard, p. 219;\n// illustrates that @* is preprocessed away correctly \n\nlogic a, b, c, d, i, x, y, tmp1, tmp2, kid;\n\n// Example 1: Uses functions, not supported by VV\n\n// Example 2:\n// equivalent to @(a or b or c or d or tmp1 or tmp2)\nalways @* begin\n tmp1 = a & b;\n tmp2 = c & d;\n y = tmp1 | tmp2;\nend\n\n// Example 3:\n// equivalent to @(b)\nalways @* begin \n @(i) kid = b; // i is not added to @*\nend\n   \n// Example 4:\n// equivalent to @(a or b or c or d)\nalways @* begin \n x = a ^ b;\n // equivalent to @(c or d)\n @* x = c ^ d;\nend\n\n// Example 5 and 6: Uses arrays, not supported by VV\n\nendmodule\n"),("selftrigger_clk1.sv","module selftrigger_clk1;\n\n// Inspired by https://verificationacademy.com/forums/systemverilog/verilog-blocking/nonblocking-assignment-clk-generator-self-triggered\n\n// Compare with selftrigger_clk2\n\nlogic clk;\ninitial #10 clk = 0;\nalways @(clk) #10 clk = ~clk;\n\ninitial $monitor(\"time = %d, clk = %b\", $time, clk);\n\nendmodule\n"),("selftrigger_loop2.sv","module selftrigger_loop2;\n\n// Compare with selftrigger_loop1\n\nlogic a = 1'b0;\nlogic b = 1'b0;\n\n// No infinite loop since a process cannot self-trigger\n\nalways_comb begin\n b = !a;\n a = b;\nend\n\nendmodule\n"),("monitor.sv","module monitor;\n\n// Basic $monitor example\n\n// (Note that the order of execution does not matter, the output is the same.)\n\nlogic a;\n   \ninitial $monitor(\"a = %b at time %d\", a, $time);\n\ninitial begin\n a = 1'b0;\n #10 a = 1'bz;\nend\n\nendmodule\n"),("nonblocking3.sv","module nonblocking3;\n\nlogic a;\n\n// a must be 0 at end of time slot\n\ninitial begin\n a = 1'b0;\n a <= a;\nend\n\nendmodule\n"),("00/c_continuous.sv","module c_continuous;\n\n// VV also supports so-called continuous assignments\n   \n// Continuous assignments have a completely \n// different evaluation model than \"normal\" processes\n\n// E.g., the net \"a\" below has two drivers,\n// and the so-called resolution function for\n// wire nets resolves the two values to 1:\n\nwire a;\n  \nassign a = 1'b1;\nassign a = 1'bz;\n\n// For wire nets, the following drivers results in a\n// value x for the net \"b\":\n\nwire b;\n\nassign b = 1'b1;\nassign b = 1'b0;\n\n// Whereas for wand nets, the same drivers result\n// in 0:\n\nwand c;\n\nassign c = 1'b1;\nassign c = 1'b0;\n\n// (Make sure to run all events to see the correct results!)\n\nendmodule\n"),("00/d_concurrency.sv","module d_concurrency;\n\n// Processes execute from blocking statements to \n// blocking statements.\n\n// E.g., when the following process is run:\n\nlogic a, b;\n\ninitial begin\n a = 0;\n a = 1;\n // The process will not stop until here\n @(b) a = 0;\nend\n\n// This differ from what the Verilog standard suggests,\n// see \"A small, but important, concurrency problem in\n// Verilog's semantics?\" from MEMOCODE'22 for a longer\n// discussion.\n\nendmodule\n"),("00/e_values.sv","module e_values;\n\n// Currently, only bit values are supported,\n// i.e., no arrays/vectors yet.\n\n// This is because, when building this simulator,\n// I was mostly interested in how events are\n// created/propagated/maintained/etc. in Verilog.\n// Adding support for arrays does not really inform this.\n\n// But it would be nice to support arrays since\n// they are common in real-world code. So I might\n// consider adding support for them in the future...\n\n// For convenience, for now, \"0\" and \"1\" are\n// parsed as bit values rather than 32-bit integers\n// as the standard says they should.\n\nendmodule\n"),("00/a_start.sv","module a_start;\n\n// Welcome to VV, an interactive Verilog simulator!\n\n// As an introduction, let's consider the following\n// variable \"a\" and a process assigning 0 to \"a\":\n\nlogic a;\n   \ninitial a = 0;\n\n// To load a Verilog module into the simulator,\n// click \"Parse\" in the bottom-left corner.\n\n// After the module has been parsed a normalised\n// module will be shown to the right of the input \n// source code.\n\n// To the right of the normalised module,\n// VV visualises the current state of Verilog's\n// event queue and other simulation state.\n\n// The event queue consist of three regions:\n// \n// - active,\n// - inactive,\n// - and nba (nonblocking assignments).\n\n// After loading this module, you will see a\n// blue-marked event in the active region for\n// time 0.\n\n// First, see that the variable \"a\" has value x in\n// the environment. Now, clicking the blue event \n// will progress the simulation. After clicking the\n// event, the variable \"a\" now has value 0 in the\n// environment.\n\n// There are now no more events to execute in the\n// current time, therefore \"Simulation time\" is now\n// blue.\n\n// Clicking \"Simulation time\" progresses to simulation\n// to the next time slot.\n\n// Here, however, the simulation ends after this first\n// time slot -- and hence the simulation finishes when\n// clicking \"Simulation time\".\n\n// For more, see the module 00/b_more.sv.\n\nendmodule   \n"),("00/f_output.sv","module f_output;\n\n// The display tasks ($display, $monitor, etc.)\n// can be invoked in a great variety of ways;\n// e.g., see this call from p. 239:\n//\n// $monitor($time, , \"a = %b b = %b\", a, b);\n//\n// In VV, to simplify the implementation,\n// the first argument must be a format string\n// and only %b (for value) and %d (for time)\n// are supported, e.g.:\n\nlogic b = 1'b0;\n\ninitial $display(\"a = %b at time %d\", b, $time);\n\nendmodule\n"),("00/b_more.sv","module b_crash_course;\n\n// Here are some more example of what we can do in VV\n\n// Here we initially have three different blue event\n// in the active region.\n\n// Verilog is nondeterministic and events in the\n// active region can be executed in any order.\n\n// Furthermore, the execution of processes can\n// depend on events generated by other processes.\n\n// E.g., the second process wait for the clock to\n// move to high before executing.\n\n// After executing a few events, there will be a\n// blue event in the NBA region.\n\n// When clicking the NBA region, the region will move\n// to the active region and the NBA events can be executed.\n\n// (The NBA region cannot be moved until both the active and\n// inactive regions are empty.)\n\n// See 00/c_continuous.sv for more.\n\nlogic clk = 0;\nlogic foo = 1;\nlogic bar;\n\nalways #1 clk = ~clk;\n\nalways @(posedge clk)\n foo <= foo + 1;\n\nalways @(foo)\n bar <= foo;\n\nendmodule\n"),("nonblocking_cont.sv","module nonblocking_cont;\n\nlogic a;\n\nwire b;\n\nassign b = a;\n\ninitial begin\n a <= 1'b0;\n a <= 1'b1;\nend\n\nendmodule\n"),("clk_blocking.sv","module clk_blocking;\n\n// Compare with clk_nonblocking\n\nlogic clk = 0;\nalways #1 clk = ~clk;\n\nalways @(posedge clk) $display(\"RUN\");\n\nendmodule\n"),("always_comb_vs_always.sv","module always_comb_vs_always;\n\n// always_comb blocks are unconditionally run at start, always blocks are not\n\nlogic a;\nlogic b;\nlogic c = 1'b0;\n\nalways_comb a = c + 1'b1;\n\nalways @(*) b = c + 1'b1;\n\nendmodule\n\n"),("read_clk_after_posedge.sv","module read_clk_after_posedge;\n\n// Example suggested by Niklas S\246rensson during FMCAD'22\n\nlogic clk = 0;\nalways #1 clk <= ~clk;\n\n// This will always print 1\nalways @(posedge clk) $display(\"%b\", clk);\n\n//\n// Alternative:\n//\n// wire clk2;\n// assign clk2 = clk;\n//\n// always @(posedge clk) $display(\"%b\", clk2);\n//\n\nendmodule\n"),("cont_cycle.sv","module cont_cycle;\n\nwire a;\n\n// Suspicious cycle, results in a being x,\n// which is a little funny since wires otherwise has z as initial value (when not driven).\n// Requires a special case in the semantics to check if there are any drivers or not.\n\nassign a = a;\n  \ninitial $monitor(\"a = %b for time %d\", a, $time);\n\nendmodule\n"),("always_star.sv","module always_star;\n\nlogic a, b;  \n\ninitial b <= 1;\n\nalways begin\n @(b) a = 0;\n @(*) a = 1;\nend\n\ninitial $monitor(\"%b\", a);\n\nendmodule\n"),("always_comb_writes_removed.sv","module always_comb_writes_removed;\n\n// Just to check if vars written to in block are removed from sense list...\n\nlogic a;\n\ninitial a = #5 1'b1;\n\n//always @(a) a = a + 1'b1;\n//\n// the above gives 0 at time 5\n\n//vs\n\nalways @(*) a = a + 1'b1;\n//\n// most simulators give 0 at time 5 as well here (i.e. writes not removed?),\n// however, Synopsys loops forever (never printing anything at time 5)\n\ninitial $monitor(\"a = %b at time %d\", a, $time);\n\nendmodule\n"),("clk_nonblocking.sv","module clk_nonblocking;\n\n// Compare with clk_blocking\n\nlogic clk = 0;\nalways #1 clk <= ~clk;\n\nalways @(posedge clk) $display(\"RUN\");\n\nendmodule\n"),("always_comb_without_reads.sv","module always_comb_without_reads;\n\n// Test for what happens with combinational always blocks without dependencies\n\nlogic a;\n\nalways_comb a = 1'b0;\n// Aldec Riviera Pro 2020.04\n// Cadence Xcelium 20.09\n// Mentor Questa 2021.3\n// Synopsys VCS 2020.03\n// Icarus Verilog 11.0 -- warning\n//\n// all of the above simulators output 0 at time 0 and terminate normally\n\n//always @(*) a = 1'b0;\n// Aldec Riviera Pro 2020.04\n// Cadence Xcelium 20.09\n// Mentor Questa 2021.3\n// Synopsys VCS 2020.03\n// Icarus Verilog 11.0 -- warning about never trigger\n//\n// all of the above simulators output x at time 0 and terminate normally\n\n//always a = 1'b0;\n// Aldec Riviera Pro 2020.04 -- infinite loop\n// Cadence Xcelium 20.09 -- infinite loop\n// Mentor Questa 2021.3 -- infinite loop\n// Synopsys VCS 2020.03 -- infinite loop + warning about no event control/delay\n// Icarus Verilog 11.0 -- abort + warning about no delay\n\ninitial $monitor(\"a = %b at time %d\", a, $time);\n\nendmodule\n"),("nonblocking4.sv","module nonblocking4;\n\nlogic a;\n\n// a must be x at end of time slot\n\ninitial begin\n a <= a;\n a = 1'b0;\nend\n\nendmodule\n"),("selftrigger_loop1.sv","module selftrigger_loop1;\n\n// Compare with selftrigger_loop2\n\nlogic a = 1'b0;\nlogic b = 1'b0;\n\n// Infinite loop in first time slot since the processes trigger each other\n\nalways_comb b = !a;\nalways_comb a = b;\n\nendmodule\n"),("monitors.sv","module monitors;\n\n// Monitors print when something they depend on has changed during the current time slot\n\n// At most one monitor at a time can be active,\n// so the following will never print \"1\".\n//\n// It will, however, print \"2\" since the monitor printing \"2\" is not overwritten until time slot 10.\n\n// Note: The standard is not clear on what should happen if nothing changes during the time slot\n//       the monitor is installed; it seems that current simulators print unconditionally,\n//       so we are doing the same.\n\n// TODO: ADD NOTE ABOUT POSTPONED REGION...\n\ninitial begin\n $monitor(\"1\");\n $monitor(\"2\");\n #10 $monitor(\"3\");\nend\n\nendmodule\n"),("delay/blocking_delay.sv","module blocking_delay;\n\n// Simple example of delayed blocking assignment\n\nlogic a;\n\ninitial begin\n a = #3 1;\n a = #4 a;\nend\n\nendmodule\n"),("delay/assn_delay.sv","module assn_delay;\n\nlogic a;\nlogic b = 1'b0;\n\ninitial $monitor(\"time = %d, a = %b, b = %b\", $time, a, b);\n\n// Verilog also has support for \"intra-assignment timing control\", see 10.4.1 Blocking procedural assignments\n\n// To illustrate the difference between a delayed assignment and an assignment with intra-assignment delay,\n// consider the following:\n\n// The rhs will not be evaluated until time slot 15\ninitial #15 a = b;\n\n// In contrast, with intra-assignment timing control, the rhs will be evaluated\n// before the process is blocked\ninitial a = #10 b;\n\n// Just a process to change the value of b before the two above processes wake up\ninitial #5 b = 1;\n\n// Hence, at time slot 10 a will be 1 and at time slot 15 a will be 0 (since b is 0 initially)\n\nendmodule\n"),("delay/cont_assn_init_delay.sv","// Simulators seem to say the following for this one:\n// \n// x                   0\n// 1                   5\n\nmodule cont_assn_init_delay;\n  \nwire w;\n  \nassign #5 w = 1;\n  \ninitial $monitor(\"time = %d, w = %b\", $time, w);\n\nendmodule\n"),("delay/nonblocking_delay.sv","module nonblocking_delay;\n\n// Simple example of delayed nonblocking assignment\n\nlogic a, b;\n\ninitial #3 a <= 0;\n\ninitial begin\n b <= #3 1;\n b <= #4 b;\n b <= #3 1'bz;\nend\n\nendmodule\n"),("Sagdeo/ex4_1.sv","//\n// The examples in this directory are from the book\n// \"The Complete Verilog Book\" by Vivek Sagdeo\n//\n\n// Example 4-1, A sample design with structure and behavior.\n\nmodule ex4_1;\n\nreg i1, i2, i3, i4;\n// MOD: Wires implicit in original module\nwire\to1, o2, o3;\n   \nand #2 a1(o1, i1, i2), a2(o2, i3, i4);\nor r1(o3, o1, o2);\n\ninitial begin\n $monitor(\"Sim Time=%d i1=%b i2=%b i3=%b i4=%b o1=%b o2=%b o3=%b\",\n\t  $time, i1, i2, i3, i4, o1, o2, o3);\n #25 i1 = 1;\n #25 i2 = 0;\n #25 i3 = 1;\n #25 i4 = 1;\n #100 $finish;\nend\n\nendmodule\n"),("Sagdeo/ex4_5.sv","// Example 4-5. Multiple events on a reg resulting cancellation (algorithm 4-7 applied)\n\nmodule ex4_5;\n\nwire out;\nreg in1, in2;\n\nassign #5 out = in1 && in2;\n\ninitial begin\n $monitor(\"Time = %d out = %b in1=%b in2=%b\",\n\t  $time, out, in1, in2);\n // MOD: dumpfile not needed\n // $dumpfile(\"ex4_2.dmp\");\n // $dumpvars;\n // $gr_waves(out, in1, in2);\n #1 in1 = 1;\n #2 in2 = 1;\n #2 in1 = 0;\n #10 $finish;\nend\n\nendmodule\n"),("Sagdeo/ex4_4.sv","// Example 4-4. Multiple events on a reg -- but no cancellation (algorithm 4-7 applied)\n\nmodule ex4_4;\n\nwire out;\nreg in1, in2;\n\nassign #5 out = in1 || in2;\n\ninitial begin\n $monitor(\"Time = %d out = %b in1=%b in2=%b\",\n          $time, out, in1, in2);\n // MOD: dumpfile not needed\n // $dumpfile(\"ex4_2.dmp\");\n // $dumpvars;\n // $gr_waves(out, in1. in2);\n #1 in1 = 1;\n #2 in2 = 1;\n #10 $finish;\nend\n\nendmodule\n"),("Sagdeo/ex4_nondet.sv","// Unnamed example, p. 91--92\n\nmodule ex4_nondet;\n\n// MOD: rega not declared in original example since \n//      just code snippet\nlogic rega;\n\ninitial #5 rega = 1'b1;\n\ninitial #5 rega = 1'b0;\n\ninitial #6 $display(\"rega at time = %d is %b\", $time, rega);\n\n/* The above may result in 1 or 0 depending on the simulation run and the simulator tool */\n   \nendmodule\n"),("nonblocking1.sv","module nonblocking1;\n\nlogic a;\n\n// a must be 1 at end of time slot\n\ninitial begin\n a <= 1'b0;\n a <= 1'b1;\nend\n\nendmodule\n"),("selftrigger_clk2.sv","module selftrigger_clk2;\n\n// Compare with selftrigger_clk1\n\nlogic clk;\ninitial #10 clk = 0;\nalways @(clk) #10 clk <= ~clk;\n\ninitial $monitor(\"time = %d, clk = %b\", $time, clk);\n\nendmodule\n")]
)
